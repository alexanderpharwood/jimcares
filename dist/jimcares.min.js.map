{"version":3,"file":"jimcares.min.js","sources":["../src/helpers/accessor.js","../src/helpers/getPathProps.js","../src/api/getValue.js","../src/api/size.js","../src/helpers/sizeof.js","../src/api/getRoot.js","../src/helpers/setUpdatedAt.js","../src/api/trash.js","../src/api/toJson.js","../src/api/initialise.js","../src/Jim.js","../src/api/has.js","../src/api/remember.js","../src/api/writeToLS.js","../src/api/forget.js","../src/api/clear.js","../src/api/destroy.js","../src/api/count.js","../src/api/equals.js"],"sourcesContent":["function accessor(){\n\tif (typeof window.__jimcares === 'undefined') {\n\t\tthrow new Error('Jim is not initialised yet. Call Jim.init({options}) first');\n\t}\n\n\treturn window.__jimcares;\n}\n\nexport default accessor;\n","function getPathProps(path) {\n\treturn path.split('/');\n}\n\nexport default getPathProps;\n","import accessor from '../helpers/accessor.js';\nimport getPathProps from '../helpers/getPathProps.js';\n\nfunction getValue(path) {\n\tlet memory = accessor();\n\tlet pathProps = getPathProps(path);\n\n\tif (pathProps.length === 0) {\n\t\treturn memory[path].value;\n\t}\n\n\tif (typeof memory[pathProps[0]] === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tvar node = memory[pathProps[0]].value;\n\tpathProps.shift();\n\tfor (let index in pathProps) {\n\t\tnode = node[pathProps[index]];\n\t}\n\n\treturn node;\n}\n\nexport default getValue;\n","import accessor from '../helpers/accessor.js';\nimport sizeof from '../helpers/sizeof.js';\n\nfunction size(path) {\n\treturn sizeof(accessor());\n}\n\nexport default size;\n","/*\n\nsizeof.js\n\nA function to calculate the approximate memory usage of objects\n\nCreated by Kate Morley - http://code.iamkate.com/ - and released under the terms\nof the CC0 1.0 Universal legal code:\n\nhttp://creativecommons.org/publicdomain/zero/1.0/legalcode\n\n*/\n\n/* Returns the approximate memory usage, in bytes, of the specified object. The\n * parameter is:\n *\n * object - the object whose size should be determined\n */\nfunction sizeof(object){\n\n  // initialise the list of objects and size\n  var objects = [object];\n  var size    = 0;\n\n  // loop over the objects\n  for (var index = 0; index < objects.length; index ++){\n\n\t// determine the type of the object\n\tswitch (typeof objects[index]){\n\n\t  // the object is a boolean\n\t  case 'boolean': size += 4; break;\n\n\t  // the object is a number\n\t  case 'number': size += 8; break;\n\n\t  // the object is a string\n\t  case 'string': size += 2 * objects[index].length; break;\n\n\t  // the object is a generic object\n\t  case 'object':\n\n\t\t// if the object is not an array, add the sizes of the keys\n\t\tif (Object.prototype.toString.call(objects[index]) != '[object Array]'){\n\t\t  for (var key in objects[index]) size += 2 * key.length;\n\t\t}\n\n\t\t// loop over the keys\n\t\tfor (var key in objects[index]){\n\n\t\t  // determine whether the value has already been processed\n\t\t  var processed = false;\n\t\t  for (var search = 0; search < objects.length; search ++){\n\t\t\tif (objects[search] === objects[index][key]){\n\t\t\t  processed = true;\n\t\t\t  break;\n\t\t\t}\n\t\t  }\n\n\t\t  // queue the value to be processed if appropriate\n\t\t  if (!processed) objects.push(objects[index][key]);\n\n\t\t}\n\n\t}\n\n  }\n\n  // return the calculated size\n  return size;\n\n}\n\nexport default sizeof;\n","import accessor from '../helpers/accessor.js';\nimport getPathProps from '../helpers/getPathProps.js';\n\nfunction getRoot(path) {\n\tlet memory = accessor();\n\tlet pathProps = getPathProps(path);\n\n\tif (pathProps.length === 0) {\n\t\treturn memory[path].value;\n\t}\n\n\treturn memory[pathProps[0]];\n}\n\nexport default getRoot;\n","import accessor from '../helpers/accessor.js';\n\nfunction setUpdatedAt() {\n\taccessor().updated_at = new Date();\n}\n\nexport default setUpdatedAt;\n","import getRoot from './getRoot.js';\nimport setUpdatedAt from '../helpers/setUpdatedAt.js';\n\nfunction trash(path) {\n\tlet node = getRoot(path);\n\tif (typeof node === 'undefined') {\n\t\treturn false;\n\t}\n\tnode.deleted_at = new Date();\n\tsetUpdatedAt();\n\treturn true;\n}\n\nexport default trash;\n","import accessor from '../helpers/accessor.js';\n\nfunction toJson(path) {\n\treturn JSON.stringify(accessor());\n}\n\nexport default toJson;\n","/**\n * Initialise Jimcares\n * @todo This method should accept options, such as a default expiration time. It should also set up the timeout for removing properties from the cache.\n * @return bool\n */\nfunction init() {\n\twindow.__jimcares = {\n\t\t\"created_at\": new Date(),\n\t\t\"updated_at\": new Date()\n\t};\n\n\treturn true;\n}\n\nexport default init;\n","import has from './api/has.js';\nimport size from './api/size.js';\nimport trash from './api/trash.js';\nimport clear from './api/clear.js';\nimport count from './api/count.js';\nimport equals from './api/equals.js';\nimport toJson from './api/toJson.js';\nimport forget from './api/forget.js';\nimport getRoot from './api/getRoot.js';\nimport destroy from './api/destroy.js';\nimport getValue from './api/getValue.js';\nimport remember from './api/remember.js';\nimport writeToLS from './api/writeToLS.js';\nimport initialise from './api/initialise.js';\n\nclass Jim {\n\n\tstatic init() {\n\t\treturn initialise();\n\t}\n\n\t/**\n\t * Determine whether jim has the given path.\n\t *\n\t * @param string path\n\t * @return bool\n\t */\n\tstatic has(path) {\n\t\treturn has(path);\n\t}\n\n\t/**\n\t * Save a value at the given path.\n\t *\n\t * @param string path\n\t * @param mixed value\n\t * @return bool\n\t */\n\tstatic remember(path, value) {\n\t\treturn remember(path, value);\n\t}\n\n\t/**\n\t * Get the value from the given path.\n\t *\n\t * @param string path\n\t * @return mixed\n\t */\n\tstatic get(path) {\n\t\treturn getValue(path);\n\t}\n\n\t/**\n\t * Get the root from the given path.\n\t *\n\t * @param string path\n\t * @return object\n\t */\n\tstatic root(path) {\n\t\treturn getRoot(path);\n\t}\n\n\t/**\n\t * Write the cache to local storage.\n\t *\n\t * @todo optional path to store only a singe root.\n\t * @return bool\n\t */\n\tstatic writeToLS() {\n\t\treturn writeToLS();\n\t}\n\n\t/**\n\t * Soft delete the root at the given root.\n\t *\n\t * @param string path\n\t * @return bool\n\t */\n\tstatic trash(path) {\n\t\treturn trash(path);\n\t}\n\n\t/**\n\t * Check if the given path has been soft deleted.\n\t *\n\t * @param string path\n\t * @return bool\n\t */\n\tstatic isTrashed(path) {\n\t\treturn trash(path);\n\t}\n\n\t/**\n\t * Hard delete the root at the given path.\n\t *\n\t * @param string path\n\t * @return bool\n\t */\n\tstatic forget(path) {\n\t\treturn forget(path);\n\t}\n\n\t/**\n\t * Clear all roots from the cache.\n\t *\n\t * @return void\n\t */\n\tstatic clear() {\n\t\tclear()\n\t}\n\n\t/**\n\t * Destroy the entire cache.\n\t *\n\t * @return void\n\t */\n\tstatic destroy() {\n\t\tdestroy();\n\t}\n\n\t/**\n\t * Export the entire cache to json, or the given path.\n\t *\n\t * @todo optional parameter to return the json string for a given path.\n\t * @return string\n\t */\n\tstatic toJson() {\n\t\treturn toJson();\n\t}\n\n\t/**\n\t * Get the size of the entire cache in bytes.\n\t *\n\t * @todo optional size of a given path if one is provided.\n\t * @return string\n\t */\n\tstatic size() {\n\t\treturn size();\n\t}\n\n\t/**\n\t * Get the count of roots in the cache.\n\t *\n\t * @return string\n\t */\n\tstatic count() {\n\t\treturn count();\n\t}\n\n\t/**\n\t * Determine if the given value matched the value at the given path in cache.\n\t *\n\t * @param path string\n\t * @param match mixed\n\t * @return bool\n\t */\n\tstatic equals(path, match) {\n\t\treturn equals(path, match);\n\t}\n}\n\nexport default Jim;\n","import getValue from './getValue.js';\n\nfunction has(path) {\n\treturn typeof getValue(path) !== 'undefined';\n}\n\nexport default has;\n","import accessor from '../helpers/accessor.js';\nimport setUpdatedAt from '../helpers/setUpdatedAt.js';\n\nfunction remember(path, value) {\n\tif (typeof path === 'undefined') {\n\t\tthrow new Error('path cannot be undefined');\n\t}\n\n\tlet memory = accessor();\n\tlet item = memory[path] = {};\n\titem.value = value;\n\titem.created_at = new Date();\n\titem.updated_at = new Date();\n\titem.deleted_at = null;\n\tsetUpdatedAt();\n\treturn true;\n}\n\nexport default remember;\n","import toJson from './toJson.js';\n\nfunction writeToLS(path) {\n\tif (typeof(Storage) === \"undefined\") {\n\t\tconsole.error('Client does not support local storage');\n\t\treturn false;\n\t}\n\n\treturn localStorage.setItem(\"__jimcares\", toJson());\n}\n\nexport default writeToLS;\n","import accessor from '../helpers/accessor.js';\nimport getPathProps from '../helpers/getPathProps.js';\nimport setUpdatedAt from '../helpers/setUpdatedAt.js';\n\nfunction forget(path) {\n\tlet memory = accessor();\n\tlet pathProps = getPathProps(path);\n\tsetUpdatedAt();\n\treturn delete memory[path];\n}\n\nexport default forget;\n","import accessor from '../helpers/accessor.js';\nimport getPathProps from '../helpers/getPathProps.js';\nimport setUpdatedAt from '../helpers/setUpdatedAt.js';\n\nfunction clear(path) {\n\tlet memory = accessor();\n\tlet exclusions = [\"created_at\", \"updated_at\"]\n\tfor (let i in memory) {\n\t\tif (exclusions.indexOf(i) === -1) {\n\t\t\tdelete memory[i]\n\t\t}\n\t}\n}\n\nexport default clear;\n","function destroy(path) {\n\treturn delete window.__jimcares;\n}\n\nexport default destroy;\n","import accessor from '../helpers/accessor.js';\n\nfunction count(path) {\n\tlet exclusions = [\"created_at\", \"updated_at\"]\n\tlet count = 0;\n\tlet memory = accessor();\n\treturn Object.keys(memory).length - exclusions.length;\n}\n\nexport default count;\n","import getValue from './getValue.js';\n\nfunction equals(path, match) {\n\treturn getValue(path) === match;\n}\n\nexport default equals;\n"],"names":["accessor","window","__jimcares","Error","getPathProps","path","split","getValue","memory","pathProps","length","value","node","index","shift","size","object","objects","Object","prototype","toString","call","key","processed","search","push","sizeof","getRoot","setUpdatedAt","updated_at","Date","trash","deleted_at","toJson","JSON","stringify","has","item","created_at","remember","Storage","console","error","localStorage","setItem","forget","exclusions","i","indexOf","clear","keys","count","match","equals"],"mappings":"okBAAA,SAASA,YACyB,IAAtBC,OAAOC,iBACX,IAAIC,MAAM,qEAGVF,OAAOC,WCLf,SAASE,EAAaC,UACdA,EAAKC,MAAM,KCEnB,SAASC,EAASF,OACbG,EAASR,IACTS,EAAYL,EAAaC,MAEJ,IAArBI,EAAUC,cACNF,EAAOH,GAAMM,cAGe,IAAzBH,EAAOC,EAAU,SAIxBG,EAAOJ,EAAOC,EAAU,IAAIE,UAE3B,IAAIE,KADTJ,EAAUK,QACQL,EACjBG,EAAOA,EAAKH,EAAUI,WAGhBD,GClBR,SAASG,WCeT,SAAgBC,WAGVC,EAAU,CAACD,GACXD,EAAU,EAGLF,EAAQ,EAAGA,EAAQI,EAAQP,OAAQG,aAG9BI,EAAQJ,SAGhB,UAAWE,GAAQ,YAGnB,SAAUA,GAAQ,YAGlB,SAAUA,GAAQ,EAAIE,EAAQJ,GAAOH,iBAGrC,YAGgD,kBAAlDQ,OAAOC,UAAUC,SAASC,KAAKJ,EAAQJ,QACpC,IAAIS,KAAOL,EAAQJ,GAAQE,GAAQ,EAAIO,EAAIZ,WAI7C,IAAIY,KAAOL,EAAQJ,GAAO,SAGzBU,GAAY,EACPC,EAAS,EAAGA,EAASP,EAAQP,OAAQc,OAC3CP,EAAQO,KAAYP,EAAQJ,GAAOS,GAAK,CAC1CC,GAAY,QAMRA,GAAWN,EAAQQ,KAAKR,EAAQJ,GAAOS,YASvCP,EDjEDW,CAAO1B,KEDf,SAAS2B,EAAQtB,OACZG,EAASR,IACTS,EAAYL,EAAaC,UAEJ,IAArBI,EAAUC,OACNF,EAAOH,GAAMM,MAGdH,EAAOC,EAAU,ICTzB,SAASmB,IACR5B,IAAW6B,WAAa,IAAIC,KCA7B,SAASC,EAAM1B,OACVO,EAAOe,EAAQtB,eACC,IAATO,IAGXA,EAAKoB,WAAa,IAAIF,KACtBF,KACO,GCRR,SAASK,WACDC,KAAKC,UAAUnC,4OCGtBC,OAAOC,WAAa,YACL,IAAI4B,gBACJ,IAAIA,OAGZ,8BCgBIzB,UCzBZ,SAAaA,eACqB,IAAnBE,EAASF,GDyBf+B,CAAI/B,oCAUIA,EAAMM,UEnCvB,SAAkBN,EAAMM,WACH,IAATN,QACJ,IAAIF,MAAM,gCAIbkC,EADSrC,IACKK,GAAQ,UAC1BgC,EAAK1B,MAAQA,EACb0B,EAAKC,WAAa,IAAIR,KACtBO,EAAKR,WAAa,IAAIC,KACtBO,EAAKL,WAAa,KAClBJ,KACO,EFwBCW,CAASlC,EAAMM,+BASZN,UACHE,EAASF,gCASLA,UACJsB,EAAQtB,6CGxDQ,oBAAbmC,SACVC,QAAQC,MAAM,0CACP,GAGDC,aAAaC,QAAQ,aAAcX,mCHsE7B5B,UACL0B,EAAM1B,qCASGA,UACT0B,EAAM1B,kCASAA,UI9Ff,SAAgBA,OACXG,EAASR,WACGI,EAAaC,GAC7BuB,WACcpB,EAAOH,GJ2FbwC,CAAOxC,oCK/FhB,eACKG,EAASR,IACT8C,EAAa,CAAC,aAAc,kBAC3B,IAAIC,KAAKvC,GACkB,IAA3BsC,EAAWE,QAAQD,WACfvC,EAAOuC,GLmGfE,4CM3GahD,OAAOC,mDN8Hb+B,0CAUAlB,2COvIT,eAGKP,EAASR,WACNkB,OAAOgC,KAAK1C,GAAQE,OAHV,CAAC,aAAc,cAGeA,OP4IvCyC,kCAUM9C,EAAM+C,UQ1JrB,SAAgB/C,EAAM+C,UACd7C,EAASF,KAAU+C,ER0JlBC,CAAOhD,EAAM+C"}